import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';
import { EvidenceItem, Supporter, Dossier, Connection, Message } from '../types';
import { analyzeEvidenceText, generateDossierSummary, generateDossierMetadata } from '../services/geminiService';
import { useAuth } from './AuthContext';

interface DataContextType {
  evidence: EvidenceItem[];
  supporters: Supporter[];
  dossiers: Dossier[];
  connections: Connection[];
  addEvidence: (content: string, platform: EvidenceItem['platform'], date: string) => Promise<void>;
  createDossier: (title: string, description: string, evidenceIds: string[]) => Promise<void>;
  autoGenerateDossier: () => Promise<void>;
  requestConnection: (supporterId: string, initialMessage: string) => void;
  updateConnectionStatus: (connectionId: string, status: Connection['status']) => void;
  sendMessage: (connectionId: string, content: string) => void;
  isAnalyzing: boolean;
}

const DataContext = createContext<DataContextType | undefined>(undefined);

// Mock Supporters Data
const MOCK_SUPPORTERS: Supporter[] = [
  {
    id: 's1',
    name: 'Dr. Sarah Johnson',
    profession: 'therapist',
    specializations: ['Trauma', 'Cyberstalking'],
    verified: true,
    rating: 4.9,
    reviews: 42,
    responseTime: 'Within 24h',
    bio: 'Licensed clinical psychologist specializing in PTSD from digital harassment.',
    avatarUrl: 'https://picsum.photos/200/200?random=1'
  },
  {
    id: 's2',
    name: 'James Marshall, Esq.',
    profession: 'lawyer',
    specializations: ['Defamation', 'Restraining Orders'],
    verified: true,
    rating: 4.8,
    reviews: 15,
    responseTime: 'Within 48h',
    bio: 'Attorney dedicated to holding online perpetrators accountable.',
    avatarUrl: 'https://picsum.photos/200/200?random=2'
  },
  {
    id: 's3',
    name: 'Digital Rights Initiative',
    profession: 'ngo_worker',
    specializations: ['Digital Safety', 'Resources'],
    verified: true,
    rating: 5.0,
    reviews: 120,
    responseTime: 'Immediate',
    bio: 'Global NGO providing toolkit and rapid response for digital attacks.',
    avatarUrl: 'https://picsum.photos/200/200?random=3'
  }
];

export const DataProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { user } = useAuth();
  const [evidence, setEvidence] = useState<EvidenceItem[]>([]);
  const [supporters] = useState<Supporter[]>(MOCK_SUPPORTERS);
  const [dossiers, setDossiers] = useState<Dossier[]>([]);
  const [connections, setConnections] = useState<Connection[]>([]);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  const addEvidence = useCallback(async (content: string, platform: EvidenceItem['platform'], date: string) => {
    setIsAnalyzing(true);
    
    // Simulate Chain of Custody Hash (Simple mock)
    const mockHash = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    
    // Get AI Analysis
    const classification = await analyzeEvidenceText(content);

    const newItem: EvidenceItem = {
      id: Date.now().toString(),
      content,
      platform,
      timestamp: date,
      hash: mockHash,
      classification
    };

    setEvidence(prev => [newItem, ...prev]);
    setIsAnalyzing(false);
  }, []);

  const createDossier = async (title: string, description: string, evidenceIds: string[]) => {
    setIsAnalyzing(true);
    const selectedItems = evidence.filter(item => evidenceIds.includes(item.id));
    
    // Generate AI Summary for the dossier
    const texts = selectedItems.map(i => i.content);
    const summary = await generateDossierSummary(texts);

    const newDossier: Dossier = {
      id: Date.now().toString(),
      title,
      description,
      items: selectedItems,
      generatedAt: new Date().toISOString(),
      severity: selectedItems.some(e => e.classification?.severity === 'critical') ? 'Critical' : 'High',
      aiSummary: summary
    };
    setDossiers(prev => [newDossier, ...prev]);
    setIsAnalyzing(false);
  };

  const autoGenerateDossier = async () => {
    setIsAnalyzing(true);
    
    if (evidence.length === 0) {
      // In a real app we'd trigger a notification
      setIsAnalyzing(false);
      return;
    }

    // Process all current evidence
    const itemsToProcess = evidence; 
    const texts = itemsToProcess.map(i => i.content);

    try {
        const [metadata, summary] = await Promise.all([
            generateDossierMetadata(texts),
            generateDossierSummary(texts)
        ]);

        const newDossier: Dossier = {
            id: Date.now().toString(),
            title: metadata.title,
            description: metadata.description,
            items: itemsToProcess,
            generatedAt: new Date().toISOString(),
            severity: itemsToProcess.some(e => e.classification?.severity === 'critical') ? 'Critical' : 'High',
            aiSummary: summary
        };

        setDossiers(prev => [newDossier, ...prev]);
    } catch (e) {
        console.error("Auto-gen failed", e);
    } finally {
        setIsAnalyzing(false);
    }
  };

  const requestConnection = (supporterId: string, initialMessage: string) => {
    if (!user) return;
    
    const newConnection: Connection = {
      id: Date.now().toString(),
      survivorId: user.id,
      supporterId: supporterId,
      status: 'pending',
      survivorAlias: user.alias || 'Anonymous User',
      messages: [
        {
          id: Date.now().toString(),
          senderId: user.id,
          content: initialMessage,
          timestamp: new Date().toISOString()
        }
      ],
      lastUpdated: new Date().toISOString()
    };
    setConnections(prev => [...prev, newConnection]);
  };

  const updateConnectionStatus = (connectionId: string, status: Connection['status']) => {
    setConnections(prev => prev.map(c => c.id === connectionId ? { ...c, status, lastUpdated: new Date().toISOString() } : c));
  };

  const sendMessage = (connectionId: string, content: string) => {
    if (!user) return;
    const newMessage: Message = {
      id: Date.now().toString(),
      senderId: user.id,
      content,
      timestamp: new Date().toISOString()
    };

    setConnections(prev => prev.map(c => {
      if (c.id === connectionId) {
        return {
          ...c,
          messages: [...c.messages, newMessage],
          lastUpdated: new Date().toISOString()
        };
      }
      return c;
    }));
  };

  return (
    <DataContext.Provider value={{ 
      evidence, 
      supporters, 
      dossiers, 
      connections,
      addEvidence, 
      createDossier, 
      autoGenerateDossier,
      requestConnection,
      updateConnectionStatus,
      sendMessage,
      isAnalyzing 
    }}>
      {children}
    </DataContext.Provider>
  );
};

export const useData = () => {
  const context = useContext(DataContext);
  if (context === undefined) {
    throw new Error('useData must be used within a DataProvider');
  }
  return context;
};